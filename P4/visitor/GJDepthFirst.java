//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

//import jdk.nashorn.internal.codegen.SpillObjectCreator;



/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   int flag=1;
   int simexp=0;

   LinkedHashMap <Integer,String> checkpoints=new LinkedHashMap<Integer,String>();
   LinkedHashMap <String,Integer> starts=new LinkedHashMap<String,Integer>();
   LinkedHashMap <String,Integer> labels=new LinkedHashMap <String,Integer>();
   LinkedHashMap <Integer,Set<Integer>> succ=new LinkedHashMap <Integer,Set <Integer>>();
   LinkedHashMap <Integer,Set<Integer>> def=new LinkedHashMap <Integer,Set<Integer>>();
   LinkedHashMap <Integer,Set<Integer>> use=new LinkedHashMap <Integer,Set<Integer>>();
   LinkedHashMap <Integer,Set<Integer>> in=new LinkedHashMap <Integer,Set<Integer>>();
   LinkedHashMap <Integer,Set<Integer>> out=new LinkedHashMap <Integer,Set<Integer>>();
   LinkedHashMap <String,LinkedHashMap <Integer,Set<Integer>>> livein=new LinkedHashMap <String,LinkedHashMap <Integer,Set<Integer>>>();
   LinkedHashMap <String,LinkedHashMap <Integer,Set<Integer>>> liveout=new LinkedHashMap <String,LinkedHashMap <Integer,Set<Integer>>>();
   LinkedHashMap <String,LinkedHashMap <Integer,Vector<Integer>>> liveintervals=new LinkedHashMap <String,LinkedHashMap <Integer,Vector<Integer>>>();
   LinkedHashMap <String,LinkedHashMap <Integer,String>> registerallocation=new LinkedHashMap<String,LinkedHashMap<Integer,String>>();
   Vector <Integer> calls=new Vector<Integer>();
   LinkedHashMap <String,Integer> arguments=new LinkedHashMap<String,Integer>();
   LinkedHashMap <String,Integer> stackslots=new LinkedHashMap<String,Integer>();
   LinkedHashMap <String,Integer> maxargu=new LinkedHashMap<String,Integer>();
   LinkedHashMap <String,LinkedHashMap <Integer,Integer>> spilledargs=new LinkedHashMap<String,LinkedHashMap<Integer,Integer>>();
   LinkedHashMap <String,LinkedHashMap <Integer,Integer>> spilledregs=new LinkedHashMap<String,LinkedHashMap<Integer,Integer>>();
	int stmts=0;
	
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() ){
         String s=(String) n.node.accept(this,argu);
         if(flag==3) System.out.println(funcname+"_"+s);
         return n.node.accept(this,argu);}
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }

   String funcname;
   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;

      String s=(String) n.f0.accept(this, argu);
      funcname=s;

      if(flag==1) n.f0.accept(this, (A)("label"));
      else if(flag==2) n.f0.accept(this, argu);

      if(flag!=3)
      {
         n.f1.accept(this, argu);
         String arg=(String) n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);

         if(flag==1)
         {
            arguments.put(s,Integer.parseInt(arg));
            checkpoints.put(stmts,s);
         }
      }

      if(flag==3)
      {
         n.f0.accept(this, argu);      
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);

         System.out.println(s+" ["+arguments.get(s)+"] ["+stackslots.get(s)+"] ["+maxargu.get(s)+"]");

         n.f4.accept(this, (A)s);

         System.out.println("END");

         if(spilledregs.get(s).size()!=0) System.out.println("// SPILLED");
         else System.out.println("// NOT SPILLED");

         return _ret;
      }

      return _ret;
   }

//
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;

      labels.put("MAIN",stmts+1);
      funcname="MAIN";

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      arguments.put("MAIN",0);
      checkpoints.put(stmts,"MAIN");

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      
      //System.out.println(stmts);

      //printlabels();

      flag=2;
      stmts=0;

      funcname="MAIN";

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      //System.out.println(checkpoints);
      //printsucc();
      //System.out.println("\nDEF :\n");
      //printdef();
      //System.out.println("\nUSE :\n");
      //printuse();

      liveness();
      live();

      //System.out.println(checkpoints);

      //System.out.println("\nLIVENESS :\n");
      //printliveness();

      liveint();

      //System.out.println(liveintervals);

      linearscan();

      //System.out.println(spilledregs);

      //System.out.println(spilledargs);

      //System.out.println(registerallocation);

      //System.out.println(arguments);
      //System.out.println(stackslots);
      //System.out.println(maxargu);

      flag=3;
      //System.out.println(starts);

      funcname="MAIN";

      n.f0.accept(this, argu);

      System.out.println("MAIN ["+arguments.get("MAIN")+"] ["+stackslots.get("MAIN")+"] ["+maxargu.get("MAIN")+"]");

      n.f1.accept(this, (A)("MAIN"));
      n.f2.accept(this, argu);

      System.out.println("END");

      if(spilledregs.get("MAIN").size()!=0) System.out.println("// SPILLED");
      else System.out.println("// NOT SPILLED");

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      
      if(flag==1) n.f0.accept(this, (A)("label2"));
      else if(flag==2) n.f0.accept(this, argu);
      else n.f0.accept(this, argu);
      
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;  

      if(flag==1 || flag==2) stmts++;

      n.f0.accept(this, argu);

      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);

      if(flag==2)
      {
         Set <Integer> s=new HashSet <Integer>();

         if(checkpoints.get(stmts)==null) s.add(stmts+1);

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();

         def.put(stmts,s1);
         use.put(stmts,s1);
      }

      if(flag==3) System.out.println("    NOOP");

      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);

      if(flag==2)
      {
         Set <Integer> s=new HashSet <Integer>();

         if(checkpoints.get(stmts)==null) s.add(stmts+1);

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();

         def.put(stmts,s1);
         use.put(stmts,s1);
      }

      if(flag==3) System.out.println("    ERROR");
      
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      if(flag==1)
      {
         n.f0.accept(this, null);
         n.f1.accept(this, null);
         n.f2.accept(this, null);
      }

      if(flag==2)
      {
         n.f0.accept(this, argu);
         String t=(String) n.f1.accept(this, argu);
         String lab=(String) n.f2.accept(this, argu);

         Set <Integer> s=new HashSet <Integer>();

         if(checkpoints.get(stmts)==null) s.add(stmts+1);
         s.add(labels.get((funcname+"_"+lab)));

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();
         Set <Integer> s2=new HashSet <Integer>();

         s2.add(Integer.parseInt(t));

         def.put(stmts,s1);
         use.put(stmts,s2);
      }

      if(flag==3)
      {
         String func=(String) argu;
         n.f0.accept(this, argu);
         String t=(String) n.f1.accept(this, argu);
         String lab=(String) n.f2.accept(this, null);

         if(registerallocation.get(func).get(Integer.parseInt(t))==null)
         {
            int a;

            if(spilledargs.get(func).get(Integer.parseInt(t))!=null) a=spilledargs.get(func).get(Integer.parseInt(t));
            else a=spilledregs.get(func).get(Integer.parseInt(t));

            System.out.println("    ALOAD v1 SPILLEDARG "+a);

            System.out.println("    CJUMP v1 "+lab);
         }
         else System.out.println("    CJUMP "+registerallocation.get(func).get(Integer.parseInt(t))+" "+((func+"_"+lab)));
      }

      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      if(flag==1)
      {
         n.f0.accept(this, null);
         n.f1.accept(this, null);
      }

      if(flag==2)
      {
         n.f0.accept(this, argu);
         String lab=(String) n.f1.accept(this, argu);

         Set <Integer> s=new HashSet <Integer>();

         s.add(labels.get((funcname+"_"+lab)));

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();

         def.put(stmts,s1);
         use.put(stmts,s1);
      }

      if(flag==3)
      {
         String func=(String) argu;
         n.f0.accept(this, argu);
         String lab=(String) n.f1.accept(this, null);

         System.out.println("    JUMP "+((func+"_"+lab)));
      }

      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1=(String) n.f1.accept(this, argu);
      String off=(String) n.f2.accept(this, argu);
      String t2=(String) n.f3.accept(this, argu);

      if(flag==2)
      {
         Set <Integer> s=new HashSet <Integer>();

         if(checkpoints.get(stmts)==null) s.add(stmts+1);

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();
         Set <Integer> s2=new HashSet <Integer>();

         s2.add(Integer.parseInt(t1));
         s2.add(Integer.parseInt(t2));

         def.put(stmts,s1);
         use.put(stmts,s2);
      }

      if(flag==3)
      {
         String func=(String) argu;

         String temp1=registerallocation.get(func).get(Integer.parseInt(t1));
         String temp2=registerallocation.get(func).get(Integer.parseInt(t2));

         if(temp1==null)
         {
            int a;

            if(spilledargs.get(func).get(Integer.parseInt(t1))!=null) a=spilledargs.get(func).get(Integer.parseInt(t1));
            else a=spilledregs.get(func).get(Integer.parseInt(t1));

            System.out.println("    ALOAD v0 SPILLEDARG "+a);

            temp1="v0";
         }
         if(temp2==null)
         {
            int a;

            if(spilledargs.get(func).get(Integer.parseInt(t2))!=null) a=spilledargs.get(func).get(Integer.parseInt(t2));
            else a=spilledregs.get(func).get(Integer.parseInt(t2));

            System.out.println("    ALOAD v1 SPILLEDARG "+a);

            temp2="v1";
         }

         System.out.println("    HSTORE "+temp1+" "+off+" "+temp2);
      }
      
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1=(String) n.f1.accept(this, argu);
      String t2=(String) n.f2.accept(this, argu);
      String off=(String) n.f3.accept(this, argu);

      if(flag==2)
      {
         Set <Integer> s=new HashSet <Integer>();

         if(checkpoints.get(stmts)==null) s.add(stmts+1);

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();
         Set <Integer> s2=new HashSet <Integer>();

         s1.add(Integer.parseInt(t1));
         s2.add(Integer.parseInt(t2));

         def.put(stmts,s1);
         use.put(stmts,s2);
      }

      if(flag==3)
      {
         String func=(String) argu;

         String temp1=registerallocation.get(func).get(Integer.parseInt(t1));
         String temp2=registerallocation.get(func).get(Integer.parseInt(t2));

         if(temp1==null)
         {
            temp1="v0";
         }
         if(temp2==null)
         {
            int a;

            if(spilledargs.get(func).get(Integer.parseInt(t2))!=null) a=spilledargs.get(func).get(Integer.parseInt(t2));
            else a=spilledregs.get(func).get(Integer.parseInt(t2));

            System.out.println("    ALOAD v1 SPILLEDARG "+a);

            temp2="v1";
         }

         System.out.println("    HLOAD "+temp1+" "+temp2+" "+off);

         if(temp1=="v0")
         {
            int a;

            if(spilledargs.get(func).get(Integer.parseInt(t1))!=null) a=spilledargs.get(func).get(Integer.parseInt(t1));
            else a=spilledregs.get(func).get(Integer.parseInt(t1));

            System.out.println("    ASTORE SPILLEDARG "+a+" v0");
         }
      }

      return _ret;
   }

   String tem;

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String t1=(String) n.f1.accept(this, argu);
      if(flag==1) n.f2.accept(this, argu);

      if(flag==2)
      {
         Set <Integer> s2=(Set <Integer>) n.f2.accept(this, argu);

         Set <Integer> s=new HashSet <Integer>();

         if(checkpoints.get(stmts)==null) s.add(stmts+1);

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();

         s1.add(Integer.parseInt(t1));

         def.put(stmts,s1);
         use.put(stmts,s2);
      }

      if(flag==3)
      {
         String func=(String) argu;

         n.f0.accept(this, argu);
         String t=(String) n.f1.accept(this, argu);

         tem=registerallocation.get(func).get(Integer.parseInt(t));

         if(tem==null)
         {
            tem="v0";
         }

         n.f2.accept(this, argu);

         if(tem=="v0")
         {
            int a;

            if(spilledargs.get(func).get(Integer.parseInt(t))!=null) a=spilledargs.get(func).get(Integer.parseInt(t));
            else a=spilledregs.get(func).get(Integer.parseInt(t));

            System.out.println("    ASTORE SPILLEDARG "+a+" v0");
         }
      }

      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(flag==1) n.f1.accept(this, null);  
      
      if(flag==2)
      {
         String t=(String) n.f1.accept(this, argu);

         Set <Integer> s=new HashSet <Integer>();

         if(checkpoints.get(stmts)==null) s.add(stmts+1);

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();
         Set <Integer> s2=new HashSet <Integer>();

         if(t!=null) s2.add(Integer.parseInt(t));

         def.put(stmts,s1);
         use.put(stmts,s2);
      }

      if(flag==3)
      {
         String func=(String) argu;

         simexp=1;
         String t=(String) n.f1.accept(this, argu);
         simexp=0;

         System.out.println("    PRINT "+t);
      }
         
      return _ret;
   }

   String str;

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      if(flag!=3) _ret = n.f0.accept(this, argu);

      if(flag==2 && n.f0.which==3)
      {
         String t=(String) n.f0.accept(this, argu);
         Set <Integer> s=new HashSet <Integer>();

         if(t!=null)
         {
            s.add(Integer.parseInt(t));
         }
         
         _ret=(R)s;
      }

      if(flag==3)
      {
         if(n.f0.which==1 || n.f0.which==2)
         {
            n.f0.accept(this, argu);

            System.out.println("    MOVE "+tem+" "+str);
         }
         else if(n.f0.which==3)
         {
            simexp=1;
            String t=(String) n.f0.accept(this, argu);
            simexp=0;

            System.out.println("    MOVE "+tem+" "+t);
         }
         else
         {
            n.f0.accept(this, argu);

            System.out.println("    MOVE "+tem+" v0");
         }
      }

      return _ret;
   }

   Set <Integer> temps=new HashSet<Integer>();

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      if(flag!=3)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         stmts++;
      }

      n.f3.accept(this, argu);

      if(flag==2)
      {
         temps.clear();
         n.f3.accept(this, (A)"simple");
         Set <Integer> s=new HashSet <Integer>();

         if(checkpoints.get(stmts)==null) s.add(stmts+1);

         succ.put(stmts,s);

         Set <Integer> s1=new HashSet <Integer>();
         Set <Integer> s2=new HashSet <Integer>();

         if(temps.size()!=0)
         {
            Integer b=0;
            for(Integer a : temps)
            {
               b=a;
            }

            s2.add(b);
         }
         temps.clear();

         def.put(stmts,s1);
         use.put(stmts,s2);
      }

      n.f4.accept(this, argu);

      if(flag==3)
      {
         String func=(String) argu;

         n.f0.accept(this, argu);

         int l=spilledargs.get(func).size();

         for(int i=l ; i<l+8 ; i++)
         {
            System.out.println("    ASTORE SPILLEDARG "+i+" s"+(i-l));
         }

         for(int i=0,j=0 ; j<arguments.get(func) ; i++,j++)
         {
            String r=registerallocation.get(func).get(j);

            if(r!=null) System.out.println("MOVE "+r+" a"+j);
         }

         n.f1.accept(this, argu);
         n.f2.accept(this, argu);

         simexp=1;
         String t=(String) n.f3.accept(this, argu);
         simexp=0;

         System.out.println("    MOVE v0 "+t);

         for(int i=l ; i<l+8 ; i++)
         {
            System.out.println("    ALOAD s"+(i-l)+" SPILLEDARG "+i);
         }

         n.f4.accept(this, argu);
      }

      return _ret;
   }

  
   Vector <Integer> argum=new Vector <Integer>();

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;

      if(flag==1)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
      }
      else if(flag==2)
      {
         calls.add(stmts);

         n.f0.accept(this, argu);

         temps.clear();

         n.f1.accept(this, (A)"simple");
         n.f2.accept(this, argu);

         n.f3.accept(this, (A)"temp");

         Set <Integer> s=new HashSet <Integer>(temps);

         _ret=(R)s;

         n.f4.accept(this, argu);
      }

      if(flag==3)
      {
         String func=(String) argu;
         n.f0.accept(this, argu);

         n.f2.accept(this, argu);

         argum.clear();

         n.f3.accept(this, (A)"args");

         int l=spilledargs.get(func).size();
         if(func=="MAIN") l+=0;
         else l+=8;
         for(int i=l ; i<l+10  ; i++)
         {
            System.out.println("    ASTORE SPILLEDARG "+i+" t"+(i-l));
         }

         Vector <Integer> vec=new Vector <Integer>(argum);

         for(int i=0 ; i<vec.size() ; i++)
         {
            String r=registerallocation.get(func).get(vec.get(i));

            if(r==null)
            {
               int a;

               if(spilledargs.get(func).get(vec.get(i))!=null) a=spilledargs.get(func).get(vec.get(i));
               else a=spilledregs.get(func).get(vec.get(i));

               System.out.println("    ALOAD v1 SPILLEDARG "+a);

               r="v1";
            }

            if(i<4) System.out.println("    MOVE a"+i+" "+r);
            else System.out.println("    PASSARG "+(i-3)+" "+r);
         }

         simexp=1;
         String t=(String) n.f1.accept(this, argu);
         simexp=0;

         System.out.println("    CALL "+t);

         for(int i=l ; i<l+10 ; i++)
         {
            System.out.println("    ALOAD t"+(i-l)+" SPILLEDARG "+i);
         }

         n.f4.accept(this, argu);
      }

      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(flag==1) n.f1.accept(this, argu);

      if(flag==2)
      {
         String t=(String) n.f1.accept(this, argu);

         Set <Integer> s=new HashSet <Integer>() ;

         s.add(Integer.parseInt(t));

         _ret=(R)s;
      }

      if(flag==3)
      {
         simexp=1;
         String t=(String) n.f1.accept(this, argu);
         simexp=0;

         str=("HALLOCATE "+t);
      }

      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      if(flag!=3)
      {
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
      }
      
      if(flag==2)
      {
         String t1=(String) n.f1.accept(this, argu);

         temps.clear();
         n.f2.accept(this, (A)"simple");

         Set <Integer> s=new HashSet <Integer>();

         s.add(Integer.parseInt(t1));
         
         if(temps.size()!=0)
         {
            Integer b=0;
            for(Integer a : temps)
            {
               b=a;
            }

            s.add(b);
         }
         temps.clear();

         _ret=(R)s;
      }

      if(flag==3)
      {
         String func=(String) argu;

         String o=(String) n.f0.accept(this, argu);
         String t=(String) n.f1.accept(this, argu);

         String temp=registerallocation.get(func).get(Integer.parseInt(t));

         if(temp==null)
         {
            int a;

            if(spilledargs.get(func).get(Integer.parseInt(t))!=null) a=spilledargs.get(func).get(Integer.parseInt(t));
            else a=spilledregs.get(func).get(Integer.parseInt(t));

            System.out.println("    ALOAD v0 SPILLEDARG "+a);

            temp="v0";
         }

         simexp=1;
         String r=(String) n.f2.accept(this, argu);
         simexp=0;

         str=(o+" "+temp+" "+r);
      }

      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      _ret=n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;

      _ret=n.f0.accept(this, argu);

      if(flag!=3 && n.f0.which!=0) _ret=null;

      if(flag==2 && (String)(argu)=="simple" && n.f0.which==0)
      {
         temps.add(Integer.parseInt((String)_ret));
      }

      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String s=(String) n.f1.accept(this, argu);

      if(flag!=1) _ret=n.f1.accept(this,argu);

      if(flag==2 && (String)argu=="temp") temps.add(Integer.parseInt(s));

      if(flag==3 && (String)argu=="args") argum.add(Integer.parseInt(s));

      if(flag==3 && simexp==1)
      {
         String func=(String) argu;

         String t=registerallocation.get(func).get(Integer.parseInt((String)_ret)); 

         if(t==null)
         {
            int a;

            if(spilledargs.get(func).get(Integer.parseInt((String)_ret))!=null) a=spilledargs.get(func).get(Integer.parseInt((String)_ret));
            else a=spilledregs.get(func).get(Integer.parseInt((String)_ret));

            System.out.println("    ALOAD v1 SPILLEDARG "+a);

            t="v1";
         }

         _ret=(R)t;
      }

      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      _ret=n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;

      String s=(String) n.f0.accept(this, argu);

      if(flag==1 && (String)argu=="label") labels.put(s,stmts+1);
      else if(flag==1 && (String)argu=="label2") labels.put((funcname+"_"+s),stmts+1);

      return (R)s;
   }

   public void printlabels()
   {
      for (Map.Entry<String,Integer> mapElement : labels.entrySet())
      {
         String key=mapElement.getKey();
         Integer value=mapElement.getValue();

         System.out.println(key + " : " + value);
      }
   }

   public void printsucc()
   {
      for(Map.Entry<Integer,Set<Integer>> mapElement : succ.entrySet())
      {
         Integer key=mapElement.getKey();
         Set <Integer> value=mapElement.getValue();

         System.out.println(key + " : " + value);
      }
   }

   public void printdef()
   {
      for(Map.Entry<Integer,Set<Integer>> mapElement : def.entrySet())
      {
         Integer key=mapElement.getKey();
         Set <Integer> value=mapElement.getValue();

         System.out.println(key + " : " + value);
      }
   }

   public void printuse()
   {
      for(Map.Entry<Integer,Set<Integer>> mapElement : use.entrySet())
      {
         Integer key=mapElement.getKey();
         Set <Integer> value=mapElement.getValue();

         System.out.println(key + " : " + value);
      }
   }

   public void printliveness()
   {
      System.out.println("\nIN :\n");

      for(Map.Entry<String,LinkedHashMap<Integer,Set<Integer>>> mapElement : livein.entrySet())
      {
         String key=mapElement.getKey();
         LinkedHashMap <Integer,Set <Integer>> value=mapElement.getValue();

         System.out.println(key + " : ");
         printmap(value);
      }

      System.out.println("\nOUT :\n");

      for(Map.Entry<String,LinkedHashMap<Integer,Set<Integer>>> mapElement : liveout.entrySet())
      {
         String key=mapElement.getKey();
         LinkedHashMap <Integer,Set <Integer>> value=mapElement.getValue();

         System.out.println(key + " : ");
         printmap(value);
      }

   }

   public void printmap(LinkedHashMap <Integer,Set <Integer>> val)
   {
      for(Map.Entry<Integer,Set<Integer>> mapElement : val.entrySet())
      {
         Integer key=mapElement.getKey();
         Set <Integer> value=mapElement.getValue();

         System.out.println(key + " : " + value);
      }
   }

   public void liveness()
   {
      for(int i=1 ; i<=stmts ; i++)
      {
         Set <Integer> s=new HashSet<Integer>();

         in.put(i,s);
         out.put(i,s);
      }

      LinkedHashMap <Integer,Set<Integer>> in1=new LinkedHashMap <Integer,Set<Integer>>();
      LinkedHashMap <Integer,Set<Integer>> out1=new LinkedHashMap <Integer,Set<Integer>>();

      do
      {
         for(int i=1 ; i<=stmts ; i++)
         {
            Set <Integer> s1=new HashSet<Integer>(in.get(i));  
            in1.put(i,s1);

            Set <Integer> s2=new HashSet<Integer>(out.get(i));  
            out1.put(i,s2);

            //System.out.println("HI");
            Set <Integer> s5=new HashSet <Integer>();
            if(succ.get(i)!=null)
            {
               for(Integer j : succ.get(i))
               {
                  if(in.get(j)!=null) s5.addAll(in.get(j));
               }
            }
            out.put(i,s5);

            Set <Integer> s3=new HashSet <Integer>(use.get(i));
            Set <Integer> s4=new HashSet <Integer>(out.get(i));
            s4.removeAll(def.get(i));
            s3.addAll(s4);
            in.put(i,s3);
         }
      }while(!(in1.equals(in) && out1.equals(out)));
   }

   public void live()
   {
      int i=1;

      for(Map.Entry<Integer,String> mapElement : checkpoints.entrySet())
      {
         LinkedHashMap <Integer,Set<Integer>> l=new LinkedHashMap <Integer,Set<Integer>>();

         Integer key=mapElement.getKey();
         String value=mapElement.getValue();

         int maxargs=0;
         int slots=0;
         int f=0;

         while(i<=stmts && i<=key)
         {
            if(calls.contains(i))
            {
               f=1;
               maxargs=Math.max(maxargs,(use.get(i)).size()-1);
            }

            l.put(i,in.get(i));
            i++;
         }

         if(value!="MAIN") slots+=8;
         if(f==1) slots+=10;

         stackslots.put(value,slots);

         maxargu.put(value,maxargs);

         livein.put(value,l);
      }

      int j=1;

      for(Map.Entry<Integer,String> mapElement : checkpoints.entrySet())
      {
         LinkedHashMap <Integer,Set<Integer>> l=new LinkedHashMap <Integer,Set<Integer>>();

         Integer key=mapElement.getKey();
         String value=mapElement.getValue();

         starts.put(value,j);

         while(j<=stmts && j<=key)
         {
            l.put(j,out.get(j));
            j++;
         }

         liveout.put(value,l);
      }
   }

   public void liveint()
   {
      for(Map.Entry<String,LinkedHashMap<Integer,Set<Integer>>> mapElement : livein.entrySet())
      {
         String key=mapElement.getKey();
         LinkedHashMap <Integer,Set <Integer>> value=mapElement.getValue();

         LinkedHashMap<Integer,Integer> liveintstart=new LinkedHashMap<Integer,Integer>();
         LinkedHashMap<Integer,Integer> liveintend=new LinkedHashMap<Integer,Integer>();

         LinkedHashMap <Integer,Vector <Integer>> l=new LinkedHashMap <Integer,Vector <Integer>>();

         for(Map.Entry<Integer,Set<Integer>> mapElement1 : value.entrySet())
         {
            Integer key1=mapElement1.getKey();
            Set <Integer> value1=mapElement1.getValue();

            Set <Integer> d=def.get(key1);

            for(Integer temp : value.get(key1))
            {
               if(!liveintstart.containsKey(temp)) liveintstart.put(temp,key1-1);
               else if(liveintstart.get(temp)>key1) liveintstart.put(temp,key1-1);
            }

    	      for(Integer temp : d)
            {
  	  		      if(liveintstart.get(temp)==null)
               {
  	  			      liveintstart.put(temp,key1);
  	  			      liveintend.put(temp,key1);
  	  		      }
  	  		      else if(liveintend.get(temp)<key1) liveintend.put(temp,key1);
            }
    	  
            for(Integer temp : value.get(key1))
            {
               if(!liveintend.containsKey(temp))	liveintend.put(temp,key1);
               else if(liveintend.get(temp)<key1) liveintend.put(temp,key1);
            }
         }

         for(Map.Entry<Integer,Integer> mapElement2: liveintstart.entrySet())
         {
            Integer key2=mapElement2.getKey();
            Integer value2=mapElement2.getValue();

            Vector <Integer> v=new Vector <Integer>();

            if(value2==liveintend.get(key2)) v.add(value2-1);
            else v.add(value2);
            v.add(liveintend.get(key2));

            l.put(key2,v);
         }

         liveintervals.put(key,l);
      }
   }

   LinkedHashMap <Integer,String> l=new LinkedHashMap<Integer,String>();

   Vector <Integer> sregisters=new Vector <Integer>();
   Vector <Integer> tregisters=new Vector <Integer>();

   HashMap <Integer,Integer> active=new HashMap<Integer,Integer>();

   Vector <Integer> remkeys=new Vector <Integer>();

   public void linearscan()
   {
      for(Map.Entry<String,LinkedHashMap<Integer,Vector<Integer>>> mapElement : liveintervals.entrySet())
      {
         String key=mapElement.getKey();
         LinkedHashMap <Integer,Vector <Integer>> value=mapElement.getValue();

         sregisters.clear();
         tregisters.clear();

         for(int i=0 ; i<10 ; i++)
         {
            if(i<8) sregisters.add(-1);
            tregisters.add(-1);
         }

         int reg=18;

         active.clear();
         l.clear();

         LinkedHashMap <Integer,Integer> sargs=new LinkedHashMap<Integer,Integer>();
         LinkedHashMap <Integer,Integer> sregs=new LinkedHashMap<Integer,Integer>();
         int sarg=0;
         int sreg=stackslots.get(key);

         for(Map.Entry<Integer,Vector<Integer>> mapElement1 : value.entrySet())
         {
            Integer key1=mapElement1.getKey();
            Vector <Integer> value1=mapElement1.getValue();

            if(key1>=4 && key1<arguments.get(key))
            {
               sargs.put(key1,sarg);
               sarg++;
               sreg++;

               continue;
            }

            remkeys.clear();

            expireoldintervals(key1,value1);

            for(int j=0 ; j<remkeys.size() ; j++)
            {
               active.remove(remkeys.get(j));
               active=sortByValue(active);
            }

            if(active.size()==reg)
            {
               int t=spillatinterval(key1,value1,sreg);

               sregs.put(t,sreg);
               sreg++;
            }
            else
            {
               int f=1;

               for(int i=0 ; i<8 ; i++)
               {
                  if(sregisters.get(i)==-1)
                  {
                     f=0;

                     sregisters.set(i,key1);

                     l.put(key1,"s"+(Integer.toString(i)));

                     break;
                  }
               }
               if(f==1)
               {
                  for(int i=0 ; i<10 ; i++)
                  {
                     if(tregisters.get(i)==-1)
                     {
                        flag=0;

                        tregisters.set(i,key1);

                        l.put(key1,"t"+(Integer.toString(i)));

                        break;
                     }
                  }
               }

               active.put(key1,value1.get(1));
               active=sortByValue(active);
            }
         }

         spilledargs.put(key,sargs);
         spilledregs.put(key,sregs);

         stackslots.put(key,sreg);

         LinkedHashMap <Integer,String> l1=new LinkedHashMap<Integer,String>(l);

         registerallocation.put(key,l1);
      }
   }

   public void expireoldintervals(Integer temp , Vector <Integer> interval)
   {
      //System.out.println(active+" "+temp+" "+interval);
      for(Map.Entry<Integer,Integer> mapElement: active.entrySet())
      {
         Integer value=mapElement.getKey();
         Integer key=mapElement.getValue();

         if(key>interval.get(0)) return;

         int f=1;

         for(int i=0 ; i<8 ; i++)
         {
            if(sregisters.get(i)==value)
            {
               sregisters.set(i,-1);

               remkeys.add(value);

               f=0;

               break;
            }
         }
         if(f==1)
         {
            for(int i=0 ; i<10 ; i++)
            {
               if(tregisters.get(i)==value)
               {
                  tregisters.set(i,-1);

                  remkeys.add(value);

                  f=0;

                  break;
               }
            }
         }
      }
   }

   public int spillatinterval(Integer temp , Vector <Integer> interval , Integer sreg)
   {
      Integer spillkey=-1;
      Integer spillvalue=-1;

      for(Map.Entry<Integer,Integer> mapElement: active.entrySet())
      {
         Integer key=mapElement.getKey();
         Integer value=mapElement.getValue();

         spillkey=key;
         spillvalue=value;
      }

      if(spillkey!=-1 && spillkey>interval.get(1))
      {
         int f=1;

         for(int i=0 ; i<8 ; i++)
         {
            if(sregisters.get(i)==spillvalue)
            {
               sregisters.set(i,temp);

               l.put(temp,"s"+(Integer.toString(i)));

               active.remove(spillkey);
               active.put(interval.get(1),temp);

               f=0;

               break;
            }
         }
         if(f==1)
         {
            for(int i=0 ; i<10 ; i++)
            {
               if(tregisters.get(i)==spillvalue)
               {
                  tregisters.set(i,temp);

                  l.put(temp,"t"+(Integer.toString(i)));

                  active.remove(spillkey);
                  active.put(interval.get(1),temp);

                  f=0;

                  break;
               }
            }
         }

         return spillvalue;
      }

      else
      {
         return temp;
      }
   }

   public static HashMap<Integer, Integer> sortByValue(HashMap<Integer, Integer> hm)
    {
        // Create a list from elements of HashMap
        List<Map.Entry<Integer, Integer> > list =
               new LinkedList<Map.Entry<Integer, Integer> >(hm.entrySet());
 
        // Sort the list
        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer> >() {
            public int compare(Map.Entry<Integer, Integer> o1,
                               Map.Entry<Integer, Integer> o2)
            {
                return (o1.getValue()).compareTo(o2.getValue());
            }
        });
         
        // put data from sorted list to hashmap
        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();
        for (Map.Entry<Integer, Integer> aa : list) {
            temp.put(aa.getKey(), aa.getValue());
        }
        return temp;
    }

}
